# 3장 클라우드 네이티브 애플리케이션 설계

<클라우드 네이티브 애플리케이션 설계시 좋은 방법>

- 초기 설계시 운영 효율성, 보안, 안정성, 확장성, 비용의 영역을 고려하는것
- 구현 관점에서 보면 특정 문제 풀이법 빌딩블록, 패턴, 기술이 있음

3.1 클라우드 네이티브 애플리케이션 기초

- 모든 주요 클라우드 공급자들은 애플리케이션 가이드를 제공

3.1.1 운영 효율성

- 운영 효율성 = 애플리케이션을 실행하고 모니터링 방법을 고려하고, 설계를 시작할 때부터 전체 과정에 걸쳐 개선해 나가는 것
- 개발, 측정, 배움 ⇒ 프로세스 설명
- 데브옵스는 위를 구현하는 방법

<모든 것을 자동화하기>

- 클라우드 자동화는 코드형 인프라(IaC) 와 함께 사용
- 전체 환경 관리가 코드로 정의 ⇒ 환경 준비와 애플리케이션 배포 동안 에러 최소화
- 애저자원관리와 AWS CloudFormation 이 좋은예
- 자동화는 소스 코드 제어 시스템으로 환경의 변화 추적 가능 + 새로운 환경에 빠르게 확장가능
- 환경 작업 준비 자동화 + 애플리케이션의 전체 배포과정 자동화 해야 함

<모든 것을 모니터링하기>

- 모니터링 으로 애플리케이션과 환경 뿐만 아니라 애플리케이션을 어떻게 사용하는지 알 수 있음
- 모니터링 데이터 기반으로 운영 비용, 성능, 애플리케이션의 기능을 개선할 수 있음
- 아키텍처 관점에서는 전체 스택에 걸쳐 일관된 모니터링 해야 함
- 서비스 호스팅 하는 인프라 부터 애플리케이션의 특징과 기능까지 전부

<모든 것을 문서화 하기>

- 많은 팀이 함께 개발하니 OpenApi, Swagger 를 이용하는 것 추천

<변화는 점진적으로 하기>

- IaC의 장점 중 하나 = 점진적 진행 + 변경 후 되돌릴 수 있음

<장애 대비하기>

- 클라우드에서는 주기적으로 장애가 발생
- 장애를 시뮬레이션하는 것을 도와주는 테스팅 프레임워크

3.1.2 보안

- 모든 주요 클라우드 공급자들은 클라우드 환경을 안전하게 유지하기 위해 보안 전문가 집단을 고용
- 대부분의 온프레미스 환경보다 클라우드 환경이 더 안전하다는 게 일반화됨
- 그렇지만 애플리케이션의 보안을 무시하면 안됨
- 심층 방어 개념이 제일 적합
- 삼층방어 = 아키텍처 전반에 보안 장치가 구현된 방법
- 애플리케이션이 오케스트레이터상에서 실행 중인 컨테이너화된 서비스, 이벤팅 시스템, FaaS, 서비스형 데이터 스토어(DaaS)

![3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%83%E1%85%B3%20%E1%84%82%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%B5%E1%84%87%E1%85%B3%20%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20a9c84e0eed4b44a7a8265bd623b80071/Untitled.png](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%83%E1%85%B3%20%E1%84%82%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%B5%E1%84%87%E1%85%B3%20%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20a9c84e0eed4b44a7a8265bd623b80071/Untitled.png)

<컨테이너화된 서비스의 심층 방어 목록(오케스트레이터로는 쿠버네티스 사용 가정)>

1. 소스 코드 = CI단계의 하나로 코드의 취약점을 확인함. 접근 추적하고 감시
2. 컨테이너 이미지 = 꼭 필요한 포트만 노출하는지
3. 컨테이너 저장소 = 누가 저장도세 접근했는지 역할기반접근제어(RBAC) 
4. 파드 = 인증된 저장소에서만 컨테이너 이미지르 ㄹ다운로드할 수 있도록
5. 클러스터와 오케스트레이터 = 오케스트레이터를 호스팅 중인 클러스터에 인터넷으로 접근하는 게 필요한지 VPN 이 적절한지 등을 결정

3.1.3 신뢰성과 가용성

- 신뢰성 = 애플리케이션이 장애가 발생해도 여전히 작동을 신뢰할 수 있다는 것을 의미
- 가용성 = 일정 시간 동안 이용 가능하다는 것을 의미
- 서비스는 전체 시스템의 가용성을 높이기 위해 수평적 확장을 고려(한곳이 다운되도 다른 한곳 멀쩡해야함)
- 설계를 할 때 항상 재시도와 서킷 브레이커를 고려
- 시스템이 어떻게 동작하고, 복구 매커니즘이 어떻게 작동하는지 확인할 수 있는 테스트해아함

3.1.4 확장성과 비용

- 확장성과 비용은 밀접한 관계
- 어떻게 확장 + 가장 비용 효율적인 면 고려
- 투표 애플리케이션을 예를 들어 투표 앱과 결과 앱을 관리형 쿠버네티스 클러스터에 배포
- 대부분 관리형 쿠버네티스 서비스는 필요한 만큼의 노드 수를 처음에 직접 지정해야 해서 최대 부하가 얼마일지, 최대 예상 트래픽을 처리하려면 노드 수가 얼마나 필요할지 정해야 함
- 노드 수를 작게 시작하고 모든 인스턴스에 기존 노드 수로 충분한 자원을 제공하지 못하게 되면 수평적 노드 오토스케일러를 사용하는 것
- 이렇게 하면 새로운 노드를 추가하는 시간이 새로운 컨테이너를 추가하는 시간보다 오래 걸려서 예상치 못한 급격한 부하 상황에는 유용하지 못함
- 애저쿠버네티스 서비스외 가상 노드나 AWS 파게이트 같은 CaaS 오퍼링을 활용

3.2. 클라우드 네이티브 vs 전통적인 아키텍처

- 두개의 기본적인 차이점 
= 세션 상태, 애플리케이션과 설정 데이터 같은 상태를 어떻게 관리하는 가
- 전통적인 애플리케이션
⇒ 주로 상태가 있음(일반적으로 애플리케이션 상태는 컴퓨트 인스턴스ㅔ 저장되는 것을 의미)
⇒ 그러므로 로드밸런서는 사용자 요청이 항상 동일한 서버 인스턴스에 도달하기 위해 스티키 세션을 사용
- 클라우드 네이티브 애플리케이션 
⇒ 일반적으로 상태가 없음
⇒ 데이터를 다루지 않는단  의미가 아니라 데이터 때문에 사용자 경험에 영향을 주지 않으면서 컴퓨트 인스턴스의 개수를 매우 동적으로 조절할 수 있도록 설계하는 것
⇒ 클라우드 네이티브 아키텍처에서 상태는 주로 외부에 있음
⇒ 즉, 데이터가 스토리지 같은 상태 저장소에 저장되는 것을 의미

![3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%83%E1%85%B3%20%E1%84%82%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%B5%E1%84%87%E1%85%B3%20%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20a9c84e0eed4b44a7a8265bd623b80071/Untitled%201.png](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%83%E1%85%B3%20%E1%84%82%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%B5%E1%84%87%E1%85%B3%20%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20a9c84e0eed4b44a7a8265bd623b80071/Untitled%201.png)

<애플리케이션에서 일어나는 단계>

1. 클라이언트가 애플리케이션에 요청을 보냄
2. 로드밸런서가 무작위로 애플리케이션 인스턴스 0에 요청을 할당. 애플리케이션 인스턴스 0은 외부 상태 저장소에 상태를 쓰고 읽음
3. 애플리케이션 인스턴스 0에서 장애 발생 시 로드밸런서는 클라이언트의 요청을 애플리케이션 인스턴스 2로 보냄
4. 애플리케이션 인스턴스 2는 해당 요청이 처음 들어왔지만 외부 상태 저장소에서 상태를 읽어옴. 클라이언트는 장애에 전혀 영향을 받지 않음

- 상태가 없도록 서비스 유지하면 동적으로 스케일인, 스케일 아웃할 때 시스템은 사용자 경험에 영향을 주지 않고 인스턴스를 추가하고 삭제해서 스케일 인 아웃하는 걸 볼 수 있음
- 스케일 인 할 때 주의점 = 스케일인 하기 전에 해당 인스턴스의 커넥션이 모두 정리 됐는지 확인
- 모놀리식 애플리케이션은 서로 다른 구성 요소를 통합하는 기술로 대부분 서비스 오케스트레이션을 사용
- 서비스 오케스트레이션은 여러 구성 요소나 서비스가 하나처럼 작동하도록 조정하는 기술(쿠버네티스상 컨테이너 오케스트레이션과 헷갈리면 안됨)

![3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%83%E1%85%B3%20%E1%84%82%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%B5%E1%84%87%E1%85%B3%20%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20a9c84e0eed4b44a7a8265bd623b80071/Untitled%202.png](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%83%E1%85%B3%20%E1%84%82%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%B5%E1%84%87%E1%85%B3%20%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20a9c84e0eed4b44a7a8265bd623b80071/Untitled%202.png)

- 서비스 코레오그래피 
= 느슨하게 결합된 서비스 간의 요청을 조정하는 것
= 각 서비스는 격리되고 자율적이고 자신의 상태를 관리할 권한이 있음

![3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%83%E1%85%B3%20%E1%84%82%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%B5%E1%84%87%E1%85%B3%20%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20a9c84e0eed4b44a7a8265bd623b80071/Untitled%203.png](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%83%E1%85%B3%20%E1%84%82%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%B5%E1%84%87%E1%85%B3%20%E1%84%8B%E1%85%A2%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%8F%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20a9c84e0eed4b44a7a8265bd623b80071/Untitled%203.png)

- 클라우드 네이티브 아키텍처는 당연히 장애가 있을 것이라 예상하고 장애를 처리하는 매커니즘을 구현
- 전통적인 애프릴케이션은 데이터베이스 클러스터링 같은 방법으로 장애를 최소화

3.3 함수 vs 서비스

- 기존 애플리케이션을 클라우드 네이티브 애플리케이션으로 변경하기 위해 새 애플리케이션을 개발할 때 초기에 결정해야 하는 사항은 컨테이너화된 서비스(앞으로 간략하게 서비스로 언급)를 만들지 아니면 곧바로 Faas 로 갈 지 입니다.
- 즉, 단순하며 수명이 짧고 독립적인 작업에 대해 FaaS 를 이용하라고 햇지만 많은 FaaS 오퍼링은 전체 애플리케이션을 FaaS 를 이용해 구현할 수 잇게 성장
- 한 가지 제약 사항은 대부분 FaaS  오퍼링은 함수 실행 시간에 여전히 타임아웃을 설정

3.3.1  함수 시나리오

- 함수들이 상호작용 할 필요 없는 단순 병렬 실행 시나리오(ex ) 아티팩트생성, 레코드 업데이트, 맵 리듀스 함수, 배치 처리)
- 많은 IoT 시나리오가 작업을 조정하기 위해 함수를 사용(ex ) IoT 허브로 메시지를 보내서 메시지에 맞는 특정 연산을 수행하고 작업을 할당)
- 어떤 애플리케이션은 전체가 FaaS 오퍼링을 이용해서 개발 
/ 전체 애플리케이션이 함수를 이용하도록 개발했다는 것
/ Azure Durable Function, Aws Sept Function은 함수의 특징을 이용해서 전체 애플리케이션을 개발할 수 있는 함수 타입

3.3.2 함수 이용 시 고려할 점

1. 모놀리스에서 마이크로서비스로 전환 시 과제
⇒ 함수는 일반적으로 작은 '서비스' 로 나뉨
2. 함수의 제한된 수명
⇒ 대부분의 FaaS 오퍼링은 함수의 실행시간을 제한
3. 특수 하드웨어 사용 불가능
⇒ GPU 같은 것
4. 함수는 상태가 없고 네트워크로 직접 접근 불가능
⇒ 이런 이유로 FaaS 는 이벤트 주도 분산 프로그래밍 모델이나 프런트 함수용으로 API 관리 솔루션을 사용하기를 권장
5. 로컬 개발과 디버깅
⇒ 일부 FaaS 런타임은 이식성이 없어서 일부 FaaS 오퍼링은 로컬 개발하면서 디버깅 불가
6. 경제성
⇒ 컴퓨트 비용을 절약할 수 있지만 FaaS 오퍼링은 일반적으로 실행 시간에 과금

3.3.3 함수와 서비스의 조합